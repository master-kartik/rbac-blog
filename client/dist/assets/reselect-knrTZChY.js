function N(e,s=`expected a function, instead received ${typeof e}`){if(typeof e!="function")throw new TypeError(s)}function j(e,s="expected all items to be functions, instead received the following types: "){if(!e.every(c=>typeof c=="function")){const c=e.map(a=>typeof a=="function"?`function ${a.name||"unnamed"}()`:typeof a).join(", ");throw new TypeError(`${s}[${c}]`)}}var g=e=>Array.isArray(e)?e:[e];function E(e){const s=Array.isArray(e[0])?e[0]:e;return j(s,"createSelector expects all input-selectors to be functions, but received the following types: "),s}function T(e,s){const c=[],{length:a}=e;for(let n=0;n<a;n++)c.push(e[n].apply(null,s));return c}var I=class{constructor(e){this.value=e}deref(){return this.value}},O=typeof WeakRef<"u"?WeakRef:I,S=0,C=1;function v(){return{s:S,v:void 0,o:null,p:null}}function W(e,s={}){let c=v();const{resultEqualityCheck:a}=s;let n,p=0;function f(){let t=c;const{length:y}=arguments;for(let u=0,m=y;u<m;u++){const l=arguments[u];if(typeof l=="function"||typeof l=="object"&&l!==null){let r=t.o;r===null&&(t.o=r=new WeakMap);const d=r.get(l);d===void 0?(t=v(),r.set(l,t)):t=d}else{let r=t.p;r===null&&(t.p=r=new Map);const d=r.get(l);d===void 0?(t=v(),r.set(l,t)):t=d}}const i=t;let o;if(t.s===C?o=t.v:(o=e.apply(null,arguments),p++),i.s=C,a){const u=(n==null?void 0:n.deref())??n;u!=null&&a(u,o)&&(o=u,p!==0&&p--),n=typeof o=="object"&&o!==null||typeof o=="function"?new O(o):o}return i.v=o,o}return f.clearCache=()=>{c=v(),f.resetResultsCount()},f.resultsCount=()=>p,f.resetResultsCount=()=>{p=0},f}function x(e,...s){const c=typeof e=="function"?{memoize:e,memoizeOptions:s}:e;return(...n)=>{let p=0,f=0,t,y={},i=n.pop();typeof i=="object"&&(y=i,i=n.pop()),N(i,`createSelector expects an output function after the inputs, but received: [${typeof i}]`);const o={...c,...y},{memoize:u,memoizeOptions:m=[],argsMemoize:l=W,argsMemoizeOptions:r=[],devModeChecks:d={}}=o,b=g(m),w=g(r),R=E(n),h=u(function(){return p++,i.apply(null,arguments)},...b),M=l(function(){f++;const z=T(R,arguments);return t=h.apply(null,z),t},...w);return Object.assign(M,{resultFunc:i,memoizedResultFunc:h,dependencies:R,dependencyRecomputations:()=>f,resetDependencyRecomputations:()=>{f=0},lastResult:()=>t,recomputations:()=>p,resetRecomputations:()=>{p=0},memoize:u,argsMemoize:l})}}export{x as c,W as w};
